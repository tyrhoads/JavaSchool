<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ItemStack.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">2025-Fall-CS330-Java-Inventory-OOP-1</a> &gt; <a href="index.source.html" class="el_package">edu.odu.cs.cs330.items</a> &gt; <span class="el_source">ItemStack.java</span></div><h1>ItemStack.java</h1><pre class="source lang-java linenums">package edu.odu.cs.cs330.items;

/**
 * A Homogeneous--i.e., uniform--stack of Items.
 */
@SuppressWarnings({
    &quot;PMD.CloneThrowsCloneNotSupportedException&quot;,
    &quot;PMD.ProperCloneImplementation&quot;,
    &quot;PMD.OnlyOneReturn&quot;,
    &quot;PMD.LawOfDemeter&quot;,
    &quot;PMD.BeanMembersShouldSerialize&quot;,
    &quot;PMD.NullAssignment&quot;,
})
public class ItemStack implements Cloneable {
    /**
     * The specific type of item out of which this stack is built.
     */
    private Item item;

    /**
     * Represents the number of items in this stack.
     */
    private int quantity;

    /**
     * Create an empty stack composed of Air.
     */
    private ItemStack()
<span class="nc" id="L29">    {</span>
<span class="nc" id="L30">        this.item     = null;</span>
<span class="nc" id="L31">        this.quantity = 0;</span>
<span class="nc" id="L32">    }</span>

    /**
     * Create a stack of the desired type.
     *
     * @param base Item out of which the stack is composed
     */
    public ItemStack(final Item base)
    {
<span class="fc" id="L41">        this(base, 1);</span>
<span class="fc" id="L42">    }</span>

    /**
     * Create a stack of the desired type.
     *
     * @param base Item out of which the stack is composed
     * @param count number of items in this stack
     */
    public ItemStack(final Item base, final int count)
<span class="fc" id="L51">    {</span>
<span class="fc" id="L52">        this.item     = base.clone();</span>
<span class="fc" id="L53">        this.quantity = count;</span>
<span class="fc" id="L54">    }</span>

    /**
     * Retrieve the Item out of which the stack is composed.
     *
     * @return the item that serves as the base
     */
    public Item getItem()
    {
<span class="fc" id="L63">        return this.item;</span>
    }

    /**
     * Retrieve the size of the stack.
     *
     * @return the current number of items
     */
    public int size()
    {
<span class="fc" id="L73">        return this.quantity;</span>
    }

    /**
     * Add items if stacking is permitted otherwise, silently discard items.
     *
     * @param qty number of items to add
     */
    public void addItems(final int qty)
    {
<span class="fc bfc" id="L83" title="All 2 branches covered.">        if (!this.permitsStacking()) {</span>
<span class="fc" id="L84">            return;</span>
        }

<span class="fc" id="L87">        this.quantity += qty;</span>
<span class="fc" id="L88">    }</span>

    /**
     * Does the Item contained in this stack permit stacking?
     * &lt;p&gt;
     * This can be less formally phrased, is this a stackable ItemStack?
     *
     * @return true if the addition of items is permitted
     */
    public boolean permitsStacking()
    {
<span class="fc" id="L99">        return item.isStackable();</span>
    }

    /**
     * Consider two stacks to be the same if
     * they contain the same type of Item.
     */
    @Override
    public boolean equals(final Object rhs)
    {
<span class="fc bfc" id="L109" title="All 2 branches covered.">        if (!(rhs instanceof ItemStack)) {</span>
<span class="fc" id="L110">            return false;</span>
        }

<span class="fc" id="L113">        final ItemStack rhsStack = (ItemStack) rhs;</span>

<span class="fc" id="L115">        return this.item.equals(rhsStack.item);</span>
    }

    /**
     * Generate a hash code based on item.
     */
    @Override
    public int hashCode()
    {
<span class="nc" id="L124">        return this.item.hashCode();</span>
    }

    /**
     * Create a deep copy of this ItemStack.
     */
    @Override
    public ItemStack clone()
    {
<span class="fc" id="L133">        return new ItemStack(this.item, this.quantity);</span>
    }

    /**
     * Print the ItemStack directly.
     */
    @Override
    public String toString()
    {
<span class="fc bfc" id="L142" title="All 2 branches covered.">        if (!this.permitsStacking()) {</span>
<span class="fc" id="L143">            return this.item.toString();</span>
        }

<span class="fc" id="L146">        return String.join(</span>
            &quot;&quot;,
<span class="fc" id="L148">            this.item.toString(),</span>
<span class="fc" id="L149">            String.format(&quot;  Qty: %d%n&quot;, this.quantity)</span>
        );
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>